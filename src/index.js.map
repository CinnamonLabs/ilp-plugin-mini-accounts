{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from 'crypto'\nconst BtpPacket = require('btp-packet')\nimport * as WebSocket from 'ws'\nimport * as assert from 'assert'\nimport AbstractBtpPlugin, * as BtpPlugin from 'ilp-plugin-btp'\nimport * as ILDCP from 'ilp-protocol-ildcp'\nimport * as IlpPacket from 'ilp-packet'\nconst { Errors } = IlpPacket\nconst StoreWrapper = require('ilp-store-wrapper')\nimport OriginWhitelist from './lib/origin-whitelist'\nimport Token from './token'\nimport { Store, StoreWrapper } from './types'\nconst createLogger = require('ilp-logger')\nimport * as http from 'http'\nimport * as https from 'https'\n\nconst DEBUG_NAMESPACE = 'ilp-plugin-mini-accounts'\n\nfunction tokenToAccount (token: string): string {\n  return BtpPacket.base64url(crypto.createHash('sha256').update(token).digest())\n}\n\ninterface Logger {\n  info (...msg: any[]): void\n  warn (...msg: any[]): void\n  error (...msg: any[]): void\n  debug (...msg: any[]): void\n  trace (...msg: any[]): void\n}\n\nexport interface IlpPluginMiniAccountsConstructorOptions {\n  port?: number\n  wsOpts?: WebSocket.ServerOptions\n  currencyScale?: number\n  debugHostIldcpInfo?: ILDCP.IldcpResponse\n  allowedOrigins?: string[]\n  generateAccount?: boolean\n  _store?: Store\n}\n\nexport interface IlpPluginMiniAccountsConstructorModules {\n  log?: Logger\n  store?: Store\n}\n\nenum AccountMode {\n  // Account is set using the `auth_username` BTP subprotocol.\n  // A store is required in this mode.\n  Username,\n  // Account is set to sha256(token). The `auth_username` subprotocol is disallowed.\n  HashToken,\n  // Account is set to `auth_username` if available, otherwise  sha256(token) is used.\n  UsernameOrHashToken\n}\n\nfunction accountModeIsStored (mode: AccountMode): boolean {\n  return mode === AccountMode.Username || mode === AccountMode.UsernameOrHashToken\n}\n\n/* tslint:disable-next-line:no-empty */\nfunction noopTrace (...msg: any[]): void { }\n\nexport default class Plugin extends AbstractBtpPlugin {\n  static version = 2\n\n  private _port: number\n  private _wsOpts: WebSocket.ServerOptions\n  // There's an extra underscore because AbstractBtpPlugin already has a property\n  // named `_httpServer`.\n  /* tslint:disable-next-line:variable-name */\n  private _miniAccountsHttpServer: http.Server | https.Server\n  protected _currencyScale: number\n  private _debugHostIldcpInfo?: ILDCP.IldcpResponse\n  protected _log: Logger\n  private _trace: (...msg: any[]) => void\n  private _connections: Map<string, Set<WebSocket>> = new Map()\n  private _allowedOrigins: OriginWhitelist\n  private _accountMode: AccountMode\n  protected _store?: StoreWrapper\n\n  private _hostIldcpInfo: ILDCP.IldcpResponse\n  protected _prefix: string\n  // These can be overridden.\n  // TODO can this be overridden via `extends`??\n  protected _handleCustomData: (from: string, btpPacket: BtpPlugin.BtpPacket) => Promise<BtpPlugin.BtpSubProtocol[]>\n  protected _handlePrepareResponse: (destination: string, parsedIlpResponse: IlpPacket.IlpPacket, preparePacket: {\n    type: IlpPacket.Type.TYPE_ILP_PREPARE,\n    typeString?: 'ilp_prepare',\n    data: IlpPacket.IlpPrepare\n  }) => void\n\n  constructor (opts: IlpPluginMiniAccountsConstructorOptions,\n    { log, store }: IlpPluginMiniAccountsConstructorModules = {}) {\n    super({})\n    if (opts.wsOpts && opts.wsOpts.port && opts.port) {\n      throw new Error('Specify at most one of: `ops.wsOpts.port`, `opts.port`.')\n    } else if (opts.wsOpts && opts.wsOpts.port) {\n      this._port = opts.wsOpts.port\n    } else if (opts.port) {\n      this._port = opts.port\n    } else {\n      this._port = 3000\n    }\n    this._wsOpts = opts.wsOpts || { port: this._port }\n    if (this._wsOpts.server) {\n      this._miniAccountsHttpServer = this._wsOpts.server\n    }\n    this._currencyScale = opts.currencyScale || 9\n    this._debugHostIldcpInfo = opts.debugHostIldcpInfo\n\n    const _store = store || opts._store\n    this._accountMode = _store ? AccountMode.UsernameOrHashToken : AccountMode.HashToken\n    if (opts.generateAccount === true) this._accountMode = AccountMode.HashToken\n    if (opts.generateAccount === false) {\n      if (!_store) {\n        throw new Error('_store is required when generateAccount is false')\n      }\n      this._accountMode = AccountMode.Username\n    }\n\n    this._log = log || createLogger(DEBUG_NAMESPACE)\n    this._log.trace = this._log.trace || noopTrace\n\n    this._allowedOrigins = new OriginWhitelist(opts.allowedOrigins || [])\n\n    if (_store) {\n      this._store = new StoreWrapper(_store)\n    }\n  }\n\n  /* tslint:disable:no-empty */\n  // These can be overridden.\n  protected async _preConnect (): Promise<void> {}\n  // plugin-btp and plugin-mini-accounts use slightly different signatures for _connect\n  // making the mini-accounts params optional makes them kinda compatible\n  protected async _connect (address: string, authPacket: BtpPlugin.BtpPacket, opts: {\n    ws: WebSocket,\n    req: http.IncomingMessage\n  }): Promise<void> {}\n  protected async _close (account: string, err?: Error): Promise<void> {}\n  protected _sendPrepare (destination: string, parsedPacket: IlpPacket.IlpPacket): void {}\n  /* tslint:enable:no-empty */\n\n  ilpAddressToAccount (ilpAddress: string): string {\n    if (ilpAddress.substr(0, this._prefix.length) !== this._prefix) {\n      throw new Error('ILP address (' + ilpAddress + ') must start with prefix (' + this._prefix + ')')\n    }\n\n    return ilpAddress.substr(this._prefix.length).split('.')[0]\n  }\n\n  async connect (): Promise<void> {\n    if (this._wss) return\n\n    if (this._debugHostIldcpInfo) {\n      this._hostIldcpInfo = this._debugHostIldcpInfo\n    } else if (this._dataHandler) {\n      this._hostIldcpInfo = await ILDCP.fetch(this._dataHandler.bind(this))\n    } else {\n      throw new Error('no request handler registered')\n    }\n\n    this._prefix = this._hostIldcpInfo.clientAddress + '.'\n\n    if (this._preConnect) {\n      try {\n        await this._preConnect()\n      } catch (err) {\n        this._log.debug(`Error on _preConnect. Reason is: ${err.message}`)\n        throw new Error('Failed to connect')\n      }\n    }\n\n    this._log.info('listening on port ' + this._port)\n\n    if (this._miniAccountsHttpServer) {\n      this._miniAccountsHttpServer.listen(this._port)\n    }\n    const wss = this._wss = new WebSocket.Server(this._wsOpts)\n    wss.on('connection', (wsIncoming, req) => {\n      this._log.trace('got connection')\n      if (typeof req.headers.origin === 'string' && !this._allowedOrigins.isOk(req.headers.origin)) {\n        this._log.debug(`Closing a websocket connection received from a browser. Origin is ${req.headers.origin}`)\n        this._log.debug('If you are running moneyd, you may allow this origin with the flag --allow-origin.' +\n          ' Run moneyd --help for details.')\n        wsIncoming.close()\n        return\n      }\n\n      let token: string\n      let account: string\n\n      const closeHandler = (error?: Error) => {\n        this._log.debug('incoming ws closed. error=', error)\n        if (account) this._removeConnection(account, wsIncoming)\n        if (this._close) {\n          this._close(this._prefix + account, error)\n            .catch(e => {\n              this._log.debug('error during custom close handler. error=', e)\n            })\n        }\n      }\n\n      wsIncoming.on('close', closeHandler)\n      wsIncoming.on('error', closeHandler)\n\n      // The first message must be an auth packet\n      // with the macaroon as the auth_token\n      let authPacket: BtpPlugin.BtpPacket\n      wsIncoming.once('message', async (binaryAuthMessage) => {\n        try {\n          authPacket = BtpPacket.deserialize(binaryAuthMessage)\n          assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet')\n          assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols')\n          assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth')\n          for (let subProtocol of authPacket.data.protocolData) {\n            if (subProtocol.protocolName === 'auth_token') {\n              // TODO: Do some validation on the token\n              token = subProtocol.data.toString()\n            } else if (subProtocol.protocolName === 'auth_username') {\n              account = subProtocol.data.toString()\n            }\n          }\n          assert(token, 'auth_token subprotocol is required')\n\n          switch (this._accountMode) {\n            case AccountMode.Username:\n              assert(account, 'auth_username subprotocol is required')\n              break\n            case AccountMode.HashToken:\n              assert(!account || account === tokenToAccount(token),\n                'auth_username subprotocol is not available')\n              break\n          }\n          // Default the account to sha256(token).\n          if (!account) account = tokenToAccount(token)\n\n          this._addConnection(account, wsIncoming)\n\n          this._log.trace('got auth info. token=' + token, 'account=' + account)\n          if (accountModeIsStored(this._accountMode) && this._store) {\n            const storedToken = await Token.load({ account, store: this._store })\n            const receivedToken = new Token({ account, token, store: this._store })\n            if (storedToken) {\n              if (!storedToken.equal(receivedToken)) {\n                throw new Error('incorrect token for account.' +\n                  ' account=' + account +\n                  ' token=' + token)\n              }\n            } else {\n              receivedToken.save()\n            }\n          }\n\n          if (this._connect) {\n            await this._connect(this._prefix + account, authPacket, {\n              ws: wsIncoming,\n              req\n            })\n          }\n\n          wsIncoming.send(BtpPacket.serializeResponse(authPacket.requestId, []))\n        } catch (err) {\n          if (authPacket) {\n            this._log.debug('not accepted error during auth. error=\"%s\" readyState=%d', err, wsIncoming.readyState)\n            const errorResponse = BtpPacket.serializeError({\n              code: 'F00',\n              name: 'NotAcceptedError',\n              data: err.message || err.name,\n              triggeredAt: new Date().toISOString()\n            }, authPacket.requestId, [])\n            if (wsIncoming.readyState === WebSocket.OPEN) {\n              wsIncoming.send(errorResponse)\n            }\n          }\n          wsIncoming.close()\n          return\n        }\n\n        this._log.trace('connection authenticated')\n\n        wsIncoming.on('message', async (binaryMessage) => {\n          let btpPacket\n          try {\n            btpPacket = BtpPacket.deserialize(binaryMessage)\n          } catch (err) {\n            wsIncoming.close()\n            return\n          }\n          this._log.trace('account %s: processing btp packet %o', account, btpPacket)\n          try {\n            this._log.trace('packet is authorized, forwarding to host')\n            await this._handleIncomingBtpPacket(this._prefix + account, btpPacket)\n          } catch (err) {\n            this._log.debug('btp packet not accepted. error=\"%s\" readyState=%d', err, wsIncoming.readyState)\n            const errorResponse = BtpPacket.serializeError({\n              code: 'F00',\n              name: 'NotAcceptedError',\n              triggeredAt: new Date().toISOString(),\n              data: err.message\n            }, btpPacket.requestId, [])\n            // The websocket may have been closed during _handleIncomingBtpPacket.\n            if (wsIncoming.readyState === WebSocket.OPEN) {\n              wsIncoming.send(errorResponse)\n            }\n          }\n        })\n      })\n    })\n  }\n\n  async disconnect () {\n    if (this._disconnect) {\n      await this._disconnect()\n    }\n\n    if (this._wss) {\n      const wss = this._wss\n      // Close the websocket server\n      await new Promise((resolve) => wss.close(resolve))\n      // The above doesn't wait until the individual sockets have been closed. So they wouldn't be removed before this function returns.\n      // Remove the individual sockets manually\n      this._connections.clear()\n\n      if (this._miniAccountsHttpServer) {\n        await new Promise((resolve) => {\n          this._miniAccountsHttpServer.close(resolve)\n        })\n      }\n      this._wss = null\n    }\n  }\n\n  isConnected () {\n    return !!this._wss\n  }\n\n  async sendData (buffer: Buffer): Promise<Buffer> {\n    const parsedPacket = IlpPacket.deserializeIlpPacket(buffer)\n    if (parsedPacket.type !== IlpPacket.Type.TYPE_ILP_PREPARE) {\n      throw new Error(`can't route packet that's not a PREPARE.`)\n    }\n    const { destination, expiresAt, executionCondition } = parsedPacket.data\n\n    if (this._sendPrepare) {\n      this._sendPrepare(destination, parsedPacket)\n    }\n\n    if (destination === 'peer.config') {\n      return ILDCP.serializeIldcpResponse(this._hostIldcpInfo)\n    }\n\n    if (!destination.startsWith(this._prefix)) {\n      throw new Error(`can't route packet that is not meant for one of my clients. destination=${destination} prefix=${this._prefix}`)\n    }\n\n    let timeout: NodeJS.Timer\n    const duration = expiresAt.getTime() - Date.now()\n\n    // TODO create a constant\n    const timeoutPacket = () =>\n      IlpPacket.serializeIlpReject({\n        code: 'R00',\n        message: 'Packet expired',\n        triggeredBy: this._hostIldcpInfo.clientAddress,\n        data: Buffer.alloc(0)\n      })\n\n    // Set timeout to expire the ILP packet\n    const timeoutPromise = new Promise<Buffer>(resolve => {\n      timeout = setTimeout(() => resolve(\n        timeoutPacket()\n      ), duration)\n    })\n\n    // Forward ILP packet to peer over BTP\n    const responsePromise = this._call(destination, {\n      type: BtpPacket.TYPE_MESSAGE,\n      requestId: crypto.randomBytes(4).readUInt32BE(0),\n      data: {\n        protocolData: [{\n          protocolName: 'ilp',\n          contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n          data: buffer\n        }]\n      }\n    }).then(response =>\n      // Extract the ILP packet from the BTP response\n      response.protocolData.filter(p => p.protocolName === 'ilp')[0].data\n    )\n\n    const ilpResponse = await Promise.race([\n      timeoutPromise,\n      responsePromise\n    ])\n\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    clearTimeout(timeout!)\n\n    const parsedIlpResponse = IlpPacket.deserializeIlpPacket(ilpResponse)\n\n    if (parsedIlpResponse.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n      // In case the plugin is overloaded with events, confirm the FULFILL hasn't expired\n      const isExpired = Date.now() > expiresAt.getTime()\n      if (isExpired) {\n        return timeoutPacket()\n      }\n\n      const { fulfillment } = parsedIlpResponse.data\n      if (!crypto.createHash('sha256')\n        .update(fulfillment)\n        .digest()\n        .equals(executionCondition)) {\n        return IlpPacket.errorToReject(this._hostIldcpInfo.clientAddress,\n          new Errors.WrongConditionError(\n            'condition and fulfillment don\\'t match. ' +\n            `condition=${executionCondition.toString('hex')} ` +\n            `fulfillment=${fulfillment.toString('hex')}`))\n      }\n    }\n\n    if (this._handlePrepareResponse) {\n      try {\n        this._handlePrepareResponse(destination, parsedIlpResponse, parsedPacket)\n      } catch (e) {\n        return IlpPacket.errorToReject(this._hostIldcpInfo.clientAddress, e)\n      }\n    }\n\n    return ilpResponse || Buffer.alloc(0)\n  }\n\n  protected async _handleData (from: string, btpPacket: BtpPlugin.BtpPacket): Promise<BtpPlugin.BtpSubProtocol[]> {\n    const { ilp } = this.protocolDataToIlpAndCustom(btpPacket.data)\n\n    if (ilp) {\n      const parsedPacket = IlpPacket.deserializeIlpPacket(ilp)\n\n      if (parsedPacket.data['destination'] === 'peer.config') {\n        this._log.trace('responding to ILDCP request. clientAddress=%s', from)\n        return [{\n          protocolName: 'ilp',\n          contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n          data: await ILDCP.serve({\n            requestPacket: ilp,\n            handler: async () => ({\n              ...this._hostIldcpInfo,\n              clientAddress: from\n            }),\n            serverAddress: this._hostIldcpInfo.clientAddress\n          })\n        }]\n      }\n    }\n\n    if (this._handleCustomData) {\n      this._log.trace('passing non-ILDCP data to custom handler')\n      return this._handleCustomData(from, btpPacket)\n    }\n\n    if (!ilp) {\n      this._log.debug('invalid packet, no ilp protocol data. from=%s', from)\n      throw new Error('invalid packet, no ilp protocol data.')\n    }\n\n    if (!this._dataHandler) {\n      throw new Error('no request handler registered')\n    }\n\n    const response = await this._dataHandler(ilp)\n    return this.ilpAndCustomToProtocolData({ ilp: response })\n  }\n\n  // TODO properly await Promise.all(map(...))\n  protected async _handleOutgoingBtpPacket (to: string, btpPacket: BtpPlugin.BtpPacket) {\n    if (!to.startsWith(this._prefix)) {\n      throw new Error(`invalid destination, must start with prefix. destination=${to} prefix=${this._prefix}`)\n    }\n\n    const account = this.ilpAddressToAccount(to)\n    const connections = this._connections.get(account)\n\n    if (!connections) {\n      throw new Error('No clients connected for account ' + account)\n    }\n\n    connections.forEach((wsIncoming) => {\n      const result = new Promise(resolve => wsIncoming.send(BtpPacket.serialize(btpPacket), resolve))\n\n      result.catch(err => {\n        const errorInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err)\n        this._log.debug('unable to send btp message to client: %s; btp packet: %o', errorInfo, btpPacket)\n      })\n    })\n  }\n\n  private _addConnection (account: string, wsIncoming: WebSocket) {\n    let connections = this._connections.get(account)\n    if (!connections) {\n      this._connections.set(account, connections = new Set())\n    }\n    connections.add(wsIncoming)\n  }\n\n  private _removeConnection (account: string, wsIncoming: WebSocket) {\n    const connections = this._connections.get(account)\n    if (!connections) return\n    connections.delete(wsIncoming)\n    if (connections.size === 0) {\n      this._connections.delete(account)\n    }\n  }\n}\n"]}